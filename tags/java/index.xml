<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 保罗札记</title>
    <link>https://www.zengxi.net/tags/java/</link>
    <description>Recent content in java on 保罗札记</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Mon, 21 Jun 2021 16:10:00 +0800</lastBuildDate><atom:link href="https://www.zengxi.net/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 9新特性 - (3)@SafeVarargs注解支持私有方法</title>
      <link>https://www.zengxi.net/2021/06/java9_safevarargs_enhancement/</link>
      <pubDate>Mon, 21 Jun 2021 16:10:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java9_safevarargs_enhancement/</guid>
      <description>Java 7 引入了@SafeVarargs注解来抑制当方法具有varargs（可变数量的参数）时出现的不安全操作警告,比如具有模糊类型（比如：泛型）的可变参数。@SafeVarargs注解只能用于无法覆盖的方法（final方法、static方法或构造函数），因为重写方法仍然可以对其 varargs（可变数量的参数）执行不安全操作。
Java 9 扩展了@SafeVarargs注解的使用，它现在也可以与私有方法一起使用。这是因为私有方法也是无法覆盖的。
Java 9 示例 - 当不使用@SafeVarargs注解时
1import java.util.ArrayList; 2import java.util.List; 3public class JavaExample{ 4 // We are not using @SafeVarargs annotation - Java 9 5 private void print(List... names) { 6 for (List&amp;lt;String&amp;gt; name : names) { 7 System.out.println(name); 8 } 9 } 10 public static void main(String[] args) { 11 JavaExample obj = new JavaExample(); 12 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); 13 list.add(&amp;#34;Kevin&amp;#34;); 14 list.</description>
    </item>
    
    <item>
      <title>Java 9新特性 - (2)匿名内部类与菱形运算符</title>
      <link>https://www.zengxi.net/2021/06/java9_anonymous_inner_class_and_diamond_operator/</link>
      <pubDate>Mon, 21 Jun 2021 15:30:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java9_anonymous_inner_class_and_diamond_operator/</guid>
      <description>什么是菱形运算符 菱形操作符是作为 java SE 7 中的新功能引入的。菱形操作符的目的是通过将泛型类型保留在表达式的右侧来避免冗余代码。
1// Java 7之前的写法 2List&amp;lt;string&amp;gt; myList = new ArrayList&amp;lt;string&amp;gt;(); 3 4// Java 7及之后的写法 5List&amp;lt;string&amp;gt; myList = new ArrayList&amp;lt;&amp;gt;(); Java 7 允许我们在普通类中使用菱形运算符，但它不允许我们在匿名内部类中使用它们。
1abstract class MyClass&amp;lt;T&amp;gt;{ 2 abstract T add(T num, T num2); 3} 4public class JavaExample { 5 public static void main(String[] args) { 6 MyClass&amp;lt;Integer&amp;gt; obj = new MyClass&amp;lt;&amp;gt;() { 7 Integer add(Integer x, Integer y) { 8 return x+y; 9 } 10 }; 11 Integer sum = obj.</description>
    </item>
    
    <item>
      <title>Java 9新特性 - (1)接口中的私有方法</title>
      <link>https://www.zengxi.net/2021/06/java9_interface_private_method/</link>
      <pubDate>Fri, 18 Jun 2021 17:22:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java9_interface_private_method/</guid>
      <description>在Java 7或更早版本中，一个接口中只能定义如下两种：
 常量 抽象方法  在Java 8中接口引入了默认方法和静态方法。可以在接口中编写方法实现，仅仅需要使用default关键字来定义它们。
Java 9提供了新的功能,可以在接口中使用private关键字定义私有方法和私有静态方法，这些私有方法的作用是用于改善接口内部的代码可重用性。例如，如果需要两个默认方法来共享代码，则私有接口方法将允许它们共享代码，但不将该私有方法暴露给它的实现类调用。
截止至Java 9，一个接口中能定义如下几种：
 常量 (Java 7及以前版本支持) 抽象方法 (Java 7及以前版本支持) 默认方法 （Java 8+） 静态方法 （Java 8+） 私有方法 （Java 9+） 私有静态方法 （Java 9+）  可以使用private访问修饰符在接口中编写私有方法。在接口中使用私有方法有四个规则：
 接口中private方法不能是abstract抽象方法。因为abstract抽象方法是公开的用于给接口实现类实现的方法，所以不能是private。 接口中私有方法只能在接口内部的方法里面被调用。 接口中私有静态方法可以在其他静态和非静态接口方法中使用。 接口中私有非静态方法不能在私有静态方法内部使用。  1interface CustomInterface { 2 3 public abstract void abstractMethod(); //抽象方法不能是私有的 4 5 public default void defaultMethod() { 6 privateMethod(); //可以调用接口中的私有方法 7 privateStaticMethod(); //可以调用接口中的私有静态方法 8 System.out.println(&amp;#34;普通方法被调用&amp;#34;); 9 } 10 11 public static void staticMethod() { 12 privateStaticMethod(); //public静态方法可以调用private静态方法 13 System.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (13)StampedLock</title>
      <link>https://www.zengxi.net/2021/06/java8_stamped_lock/</link>
      <pubDate>Tue, 08 Jun 2021 13:37:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java8_stamped_lock/</guid>
      <description>synchronized 在java5之前，实现同步主要是使用synchronized。它是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 有四种不同的同步块:
 实例方法 静态方法 实例方法中的同步块 静态方法中的同步块  在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，性能上也有所提升。
Lock 它是Java 5在java.util.concurrent.locks新增的一个API。
Lock是一个接口，核心方法是lock()，unlock()，tryLock()，实现类有ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock； ReentrantReadWriteLock, ReentrantLock 和synchronized锁都有相同的内存语义。
与synchronized不同的是，Lock完全用Java写成，在java这个层面是无关JVM实现的。Lock提供更灵活的锁机制，很多synchronized 没有提供的许多特性，比如锁投票，定时锁等候和中断锁等候，但因为lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中
StampedLock StampedLock是java.util.concurrent.locks包里面jdk 8版本新增的一个锁，该锁提供了三种模式的读写控制，三种模式分别如下：
 写锁 writeLock
是个排它锁或者叫独占锁，同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当目前没有线程持有读锁或者写锁的时候才可以获取到该锁，请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockWrite并传递参数stamp。 悲观读锁 readLock
是个共享锁，在没有线程获取独占写锁的情况下，同时多个线程可以获取该锁，如果已经有线程持有写锁，其他线程请求获取该读锁会被阻塞。这里讲的悲观其实是参考数据库中的乐观悲观锁的，这里说的悲观是说在具体操作数据前悲观的认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑,请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockRead并传递参数stamp。 乐观读锁 tryOptimisticRead
是相对于悲观锁来说的，在操作数据前并没有通过CAS设置锁的状态，如果当前没有线程持有写锁，则简单的返回一个非0的stamp版本信息，获取该stamp后在具体操作数据前还需要调用validate验证下该stamp是否已经不可用，也就是看当调用tryOptimisticRead返回stamp后到到当前时间间是否有其他线程持有了写锁，如果是那么validate会返回0，否者就可以使用该stamp版本的锁对数据进行操作。由于tryOptimisticRead并没有使用CAS设置锁状态所以不需要显示的释放该锁。该锁的一个特点是适用于读多写少的场景，因为获取读锁只是使用与或操作进行检验，不涉及CAS操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。  1class Point { 2 3 // 成员变量 4 private double x, y; 5 6 // 锁实例 7 private final StampedLock sl = new StampedLock(); 8 9 // 排它锁-写锁（writeLock） 10 void move(double deltaX, double deltaY) { 11 long stamp = sl.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (12)无符号运算</title>
      <link>https://www.zengxi.net/2021/06/java8_unsigned_arithmetic/</link>
      <pubDate>Tue, 08 Jun 2021 12:59:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java8_unsigned_arithmetic/</guid>
      <description>Java 8为整型包装类，增加类支持无符号运算的方法。注意：仅仅是在新增的运算方法中将long或者int当做无符号的数做运算，而本身java并不支持无符号的数据类型
Java 8为Integer，Long新增如下方法:
1// 该方法将指定int货long型整数转换为无符号整数对应的字符串 2static String toUnsignedString(int/long i) 3 4// 该方法将指定int或long型整数转换为指定进制的无符号整数对应的字符串 5static String toUnsignedString(int i/long,int radix) 6 7// 该方法将指定字符串解析成无符号整数。当调用类为Integer时，xxx代表int；当调用类是Long时，xxx代表long 8static xxx parseUnsignedXxx(String s) 9 10// 该方法将指定字符串按指定进制解析成无符号整数。当调用类为Integer时，xxx代表int；当调用是Long时，xxx代表long 11static xxx parseUnsignedXxx(String s,int radix) 12 13// 该方法将x，y两个整数转换为无符号整数后比较大小。当调用类为Integer时，xxx代表int；当调用类是Long时，xxx代表long 14static int compareUnsigned(xxx x,xxx y) 15 16// 该方法将x、y两个整数转换为无符号整数后计算他们相除的商。当调用类为Integer时，xxx代表int；当调用类是Long时，xxx代表long 17static long divideUnsigned(long dividend,long divisor) 18 19// 该方法将x、y两个整数转换为无符号整数后计算他们相除的余数。当调用类为Integer是，xxx代表int；当调用类是Long时，xxx代表long 20static long remainderUnsigned(long dividend,long divisor) java 8还为Byte、Short增加了toUnsignedInt(xxx x) utoUnsignedLong(yyy x)两个方法，这两个方法用于将指定byte或short类型的变量或值转换成无符号的int或long值
 参考：
 https://blog.csdn.net/weixin_39788792/article/details/114201083  </description>
    </item>
    
    <item>
      <title>Java 8新特性 - (11)Base64编解码</title>
      <link>https://www.zengxi.net/2021/06/java8_base64/</link>
      <pubDate>Mon, 07 Jun 2021 12:59:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java8_base64/</guid>
      <description>早期处理BASE64编码, 需借助外部依赖：commons-codec，sun.misc.BASE64Decoder或JAXB的DatatypeConverter。Java 8实现了BASE64编解码API，它包含到java.util包。
java.util.Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：
 Basic编码 URL编码 MIME编码  Basic编码 Basic编码是标准的BASE64编码，用于处理常规的需求：输出的内容不添加换行符，而且输出的内容由字母加数字组成。
1// 编码 2String asB64 = Base64.getEncoder().encodeToString(&amp;#34;some string&amp;#34;.getBytes(&amp;#34;utf-8&amp;#34;)); 3System.out.println(asB64); // 输出为: c29tZSBzdHJpbmc= 4 5// 解码 6byte[] asBytes = Base64.getDecoder().decode(&amp;#34;c29tZSBzdHJpbmc=&amp;#34;); 7System.out.println(new String(asBytes, &amp;#34;utf-8&amp;#34;)); // 输出为: some string URL编码 URL编码也是经常的需求，但由于URL对反斜线“/”有特殊的意义，因此URL编码需要替换掉它，使用下划线替换
1String basicEncoded = Base64.getEncoder().encodeToString(&amp;#34;subjects?abcd&amp;#34;.getBytes(&amp;#34;utf-8&amp;#34;)); 2System.out.println(&amp;#34;Using Basic Alphabet: &amp;#34; + basicEncoded); 3 4String urlEncoded = Base64.getUrlEncoder().encodeToString(&amp;#34;subjects?abcd&amp;#34;.getBytes(&amp;#34;utf-8&amp;#34;)); 5System.out.println(&amp;#34;Using URL Alphabet: &amp;#34; + urlEncoded); 6 7// 输出为: 8Using Basic Alphabet: c3ViamVjdHM/YWJjZA== 9Using URL Alphabet: c3ViamVjdHM_YWJjZA== MIME编码 MIME编码器会使用基本的字母数字产生BASE64输出，而且对MIME格式友好：每一行输出不超过76个字符，而且每行以“\r\n”符结束。</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (10)并行数组排序</title>
      <link>https://www.zengxi.net/2021/06/java8_parallel_sort/</link>
      <pubDate>Tue, 01 Jun 2021 22:09:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java8_parallel_sort/</guid>
      <description>在Java 7中已经有了Arrays.sort()方法可对对象进行排序，而在Java 8中，引入了新的并行排序，它比前者的排序速度更快，且遵循了Java 7引入的Fork/Join框架，可以把排序任务分配给线程池中可用的多个线程。 Java 8在java.util.Arrays类中新增了并行排序功能，能够更充分地利用多线程机制，最重要的方法是parallelSort()，可以显著加快多核机器上的数组排序
并行排序算法：
 将给定的数组划分为子数组，将子数组进一步划分为子数组，直到子数组达到最小粒度为止。 子数组由多个线程单独排序。并行排序使用 Fork / Join Framework 并行地对子数组进行排序。 已合并的已排序子数组。  1// 对原始数据类型进行并行排序 2// 输出：1 5 19 22 32 89 3int numbers[] = {22, 89, 1, 32, 19, 5}; 4Arrays.parallelSort(numbers); 5 6// 通过指定开始和结束索引进行并行排序。 7// 在这种情况下，从开始索引开始并在结束索引结束的子数组被排序，数组的其余部分被忽略并且不被排序。 8// 输出：22 1 19 32 89 5 9int numbers[] = {22, 89, 1, 32, 19, 5}; 10Arrays.parallelSort(numbers, 1, 5);  参考：
 https://www.jianshu.com/p/2f038115de06 https://www.yuque.com/apachecn/beginnersbook-zh/docs_java_69  </description>
    </item>
    
    <item>
      <title>Java 8新特性 - (9)DateTime API</title>
      <link>https://www.zengxi.net/2021/06/java8_datetime_api/</link>
      <pubDate>Tue, 01 Jun 2021 14:15:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/06/java8_datetime_api/</guid>
      <description>相关背景 Java对日期、日历及时间的处理一直以来都饱受诟病：
 java.util.Date和java.util.Calendar类易用性差，不支持时区，非线程安全 用于格式化日期的类DateFormat被放在java.text包中，它是一个抽象类，所以我们需要实例化一个SimpleDateFormat对象来处理日期格式化，并且DateFormat也是非线程安全，这意味着如果你在多线程程序中调用同一个DateFormat对象，会得到意想不到的结果。 对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从Calendar中获取的月份需要加一才能表示当前月份。  由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是JSR-310规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。
简介 新的API对时间日期的处理提供了更好的支持，清楚的定义了时间日期的一些概念，比如说，瞬时时间（Instant）,持续时间（duration），日期（date）,时间（time），时区（time-zone）以及时间段（Period）。
新的时间日期API核心位于java.time内，另外也在java.time.chrono，java.time.format，java.time.temporal和java.time.zone有相关的API，但使用频次较少。时间与日期API中的所有类都是线程安全的。
Java 8常用的日期和时间类主要包括包含：
 LocalDate：不包含时间的日期，比如2019-10-14。可以用来存储生日，周年纪念日，入职日期等。 LocalTime：与LocalDate想对照，它是不包含日期的时间。 LocalDateTime：包含了日期及时间，没有偏移信息（时区）。 ZonedDateTime：包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。 Instant：时间戳，与System.currentTimeMillis()类似。 Duration：表示一个时间段。 Period：用来表示以年月日来衡量一个时间段。  LocalDate LocalDate类内只包含日期，不包含具体时间。只需要表示日期而不包含时间，就可以使用它。
1// 只获取日期 2LocalDate today = LocalDate.now(); 3System.out.println(today); 4 5int year = today.getYear(); 6int month = today.getMonthValue(); 7int day = today.getDayOfMonth(); 8 9System.out.printf(&amp;#34;Year : %d Month : %d day : %d \t %n&amp;#34;, year, month, day); 同时，还可以通过LocalDate获取日期是月份的第几天、周的第几天，月份的天数，是否为闰年等。看下面的代码是不是非常方便。
1LocalDate today = LocalDate.now(); 2// 月份中的第几天 3int dayOfMonth = today.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (8)方法参数反射</title>
      <link>https://www.zengxi.net/2021/05/java8_method_parameter_reflection/</link>
      <pubDate>Fri, 28 May 2021 18:45:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/05/java8_method_parameter_reflection/</guid>
      <description>方法的参数名，在很多时候我们是需要反射得到的。但是在java8之前，代码编译为class文件后，方法参数的类型是固定的，但参数名称却丢失了，这和动态语言严重依赖参数名称形成了鲜明对比。（java是静态语言，所以入参名称叫什么其实无所谓的）。虽然名称无所谓，但很多时候，我们需要此名称来做更好的安排.
比如mybatis的Dao层接口方法，需要特意用个注解@Param来显示标识出参数名。所以java8来了，带来的新特性解决了这一问题。
获取方法参数名称有3种方法：
采用javassit包获取 很麻烦，参考其他网上文章
通过spring的LocalVariableTableParameterNameDiscoverer 1public static void main(String[] args) { 2 List&amp;lt;String&amp;gt; paramterNames = getParamterName(StaffMark.class, &amp;#34;fun1&amp;#34;); 3 paramterNames.forEach((x) -&amp;gt; System.out.println(x)); 4} 5 6public static void fun1(String aaa, Integer bbb) { 7 8} 9 10public static List&amp;lt;String&amp;gt; getParamterName(Class clazz, String methodName) { 11 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); 12 Method[] methods = clazz.getDeclaredMethods(); 13 for (Method method : methods) { 14 if (methodName.equals(method.getName())) { 15 //获取到该方法的参数们 16 String[] params = u.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (7)泛型的类型推断</title>
      <link>https://www.zengxi.net/2021/05/java8_type_inference/</link>
      <pubDate>Fri, 28 May 2021 18:05:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/05/java8_type_inference/</guid>
      <description>泛型简介 泛型由Java 1.5引入，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点将就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。理解Java泛型最简单的方法是把它看成一种便捷语法，能节省某些Java类型转换(casting)上的操作.
泛型的最大优点是提供了程序的类型安全同时可以向后兼容，但也有尴尬的地方，就是每次定义时都要写明泛型的类型，这样显示指定不仅感觉有些冗长。Java 7中对泛型做了改进，编译器会根据变量声明时的泛型类型自动推断.
1// Java 7之前的写法 2Map&amp;lt;String, String&amp;gt; myMap = new HashMap&amp;lt;String, String&amp;gt;(); 3 4// Java 7及之后的写法 5Map&amp;lt;String, String&amp;gt; myMap = new HashMap&amp;lt;&amp;gt;(); //注意后面的&amp;#34;&amp;lt;&amp;gt;&amp;#34; 但是，Java 7在创建泛型实例时的类型推断是有限制的：只有构造器的参数化类型在上下文中被显著的声明了，才可以使用类型推断，否则不行。例如：下面的例子在java 7无法正确编译（但在java8里面可以编译，因为根据方法参数来自动推断泛型的类型）：
1List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 2list.add(&amp;#34;A&amp;#34;); 3// 由于addAll期望获得Collection&amp;lt;? extends String&amp;gt;类型的参数，因此下面的语句在Java 7中无法编译无法通过 4list.addAll(new ArrayList&amp;lt;&amp;gt;()); Java 8的泛型类型推断改进 java 8里面泛型的目标类型推断主要2个：
 支持通过方法上下文推断泛型目标类型 支持在方法调用链路当中，泛型类型推断传递到最后一个方法  看看官网的例子：
1class List&amp;lt;E&amp;gt; { 2 static &amp;lt;Z&amp;gt; List&amp;lt;Z&amp;gt; nil() { ... }; 3 static &amp;lt;Z&amp;gt; List&amp;lt;Z&amp;gt; cons(Z head, List&amp;lt;Z&amp;gt; tail) { .</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (6)类型注解</title>
      <link>https://www.zengxi.net/2021/05/java8_type_annotation/</link>
      <pubDate>Fri, 28 May 2021 12:48:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/05/java8_type_annotation/</guid>
      <description>什么是类型注解 在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；从java 8开始，注解可以应用在任何地方。但是需要注意的是，类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解。换句话说，仅提供定义这些类型的注释的功能，然后由框架和工具开发者来实际上使用它们。
主要的场景：
 创建类实例：  1new @Interned MyObject(); 类型定义：  1@NotNull String str1 = ... 2@Email String str2 = ... 类型转换：  1myString = (@NonNull String) str; 泛型  1List&amp;lt;@Email String&amp;gt; emails = ... 包括参数边界和通配符边界  1class Folder&amp;lt;F extends @Existing File&amp;gt; { ... } 2Collection&amp;lt;? super @Existing File&amp;gt; c = ... 3List&amp;lt;@Immutable ? extends Comparable&amp;lt;T&amp;gt;&amp;gt; unchangeable = ... instanceof 语句  1boolean isNonNull = myString instanceof @NonNull String; 2boolean isNonBlankEmail = myString instanceof @NotBlank @Email String; 继承  1class UnmodifiableList&amp;lt;T&amp;gt; implements @Readonly List&amp;lt;@Readonly T&amp;gt; { .</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (5)重复注解</title>
      <link>https://www.zengxi.net/2021/05/java8_repeating_annotations/</link>
      <pubDate>Thu, 27 May 2021 10:30:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/05/java8_repeating_annotations/</guid>
      <description>在JDK8之前，不能使用重复注解的，即某个位置相同注解只能出现一次。
如果想编写一个定时任务的注解，使用者可以配置在每天哪一小时触发，而且允许用户配置多个时间。传统做法是：
1@Target(ElementType.TYPE) 2@Retention(RetentionPolicy.RUNTIME) 3public @interface TraditionalAnnoSchedule { 4 int[] hour() default {0}; 5} 6 7@TraditionalAnnoSchedule(hour = {0, 8, 12}) 8public class Target { 9 public static void main(String[] args) { 10 TraditionalAnnoSchedule[] annotations = Target.class.getAnnotationsByType(TraditionalAnnoSchedule.class); 11 for (TraditionalAnnoSchedule each : annotations) { 12 System.out.println(Arrays.toString(each.hour())); 13 } 14 } 15} 使用JDK8的重复注解特性改造一下。
1@Target(ElementType.TYPE) 2@Retention(RetentionPolicy.RUNTIME) 3public @interface Schedules { 4 Schedule[] value(); 5} 6 7// JDK8新增的@Repeatable 8@Repeatable(Schedules.class) 9public @interface Schedule { 10 int hour() default 0; 11} 12 13@Schedule(hour = 0) 14@Schedule(hour = 8) 15@Schedule(hour = 12) 16public class Target { 17 public static void main(String[] args) { 18 // 推荐的方式 19 Schedule[] annotations = Target.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (4)默认方法</title>
      <link>https://www.zengxi.net/2021/05/java8_default_method/</link>
      <pubDate>Wed, 26 May 2021 22:40:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/05/java8_default_method/</guid>
      <description>什么是默认方法 简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。
为什么要有默认方法 首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。
简单的例子: 一个接口A，Clazz类实现了接口A。
1public interface A { 2 default void foo(){ 3 System.out.println(&amp;#34;Calling A.foo()&amp;#34;); 4 } 5} 6 7public class Clazz implements A { 8 public static void main(String[] args){ 9 Clazz clazz = new Clazz(); 10 clazz.foo();//调用A.foo() 11 } 12} 代码是可以编译的，即使Clazz类并没有实现foo()方法。在接口A中提供了foo()方法的默认实现。
java 8抽象类与接口对比 相同点  都是抽象类型； 都可以有实现方法（以前接口不行）； 都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）  不同点  抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）； 抽象类和接口所反映出的设计理念不同。其实抽象类表示的是&amp;quot;is-a&amp;quot;关系，接口表示的是&amp;quot;like-a&amp;quot;关系； 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。  多重继承的冲突 观察以下代码，会出现编译错误：
 java: class InterfaceC inherits unrelated defaults for f() from types InterfaceA and InterfaceB</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (3)方法引用</title>
      <link>https://www.zengxi.net/2021/04/java8_method_references/</link>
      <pubDate>Wed, 07 Apr 2021 13:01:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/04/java8_method_references/</guid>
      <description>方法引用（Method references）。方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，可以使语言的构造更紧凑简洁，减少冗余代码。
方法引用使用到的操作符“::”，这个操作符把方法引用分成两边，左边是类名或者某个对象的引用，右边是方法名。引用方法有下面几种方式：
 对象引用::实例方法名 类名::静态方法名 类名::实例方法名 类名::new 类型[]::new  对象引用::实例方法名 创建了一个PersonCompare对象，调用了其内部的compareByName实例方法。
1public class PersonCompare { 2 public int compareByName(Person a, Person b) { 3 return a.getName().compareTo(b.getName()); 4 } 5 public int compareByAge(Person a, Person b) { 6 return a.getBirthday().compareTo(b.getBirthday()); 7 } 8 @Test 9 public void test(){ 10 Person[] pArr = new Person[]{ 11 new Person(&amp;#34;1&amp;#34;, LocalDate.of(2019, 12, 1)), 12 new Person(&amp;#34;2&amp;#34;, LocalDate.of(2019, 12, 2)), 13 new Person(&amp;#34;3&amp;#34;, LocalDate.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (2)Stream API</title>
      <link>https://www.zengxi.net/2021/03/java8_stream_api/</link>
      <pubDate>Fri, 05 Mar 2021 12:56:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/03/java8_stream_api/</guid>
      <description>什么是Stream API Stream API让开发者能够以一种声明的方式处理数据源（集合、数组等），它专注于对数据源进行各种高效的聚合操作（aggregate operation）和大批量数据操作 (bulk data operation)。
Stream API将处理的数据源看做一种Stream（流），Stream（流）在Pipeline（管道）中传输和运算，支持的运算包含筛选、排序、聚合等，当到达终点后便得到最终的处理结果。如果说集合讲的的数据，那么流讲的就是计算！
几个关键概念：
 元素: Stream是一个来自数据源的元素队列，Stream本身并不存储元素。 数据源: 即Stream的来源, 包含集合、数组、I/O channel、generator（发生器）等。 聚合操作: 类似SQL中的filter、map、find、match、sorted等操作 管道运算: Stream在Pipeline中运算后返回Stream对象本身，这样多个操作串联成一个Pipeline，并形成fluent风格的代码。这种方式可以优化操作，如延迟执行(laziness)和短路( short-circuiting)。 内部迭代: 不同于java 8以前对集合的遍历方式（外部迭代），Stream API采用访问者模式（Visitor）实现了内部迭代。 并行运算: Stream API支持串行（stream()）或并行（parallelStream()）的两种操作方式。  特点：
 Stream API的使用和同样是java8新特性的lambda表达式密不可分，可以大大提高编码效率和代码可读性。 Stream API提供串行和并行两种操作，其中并行操作能发挥多核处理器的优势，使用fork/join的方式进行并行操作以提高运行速度。 Stream API进行并行操作无需编写多线程代码即可写出高效的并发程序，且通常可避免多线程代码出错的问题。  注意：
 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。  Stream操作的三个步骤  创建Stream：一个数据源（如： 集合、数组）， 获取一个流。 中间操作:一个中间操作链，对数据源的数据进行处理。 终止操作(终端操作):一个终止操作，执行中间操作链，并产生结果。  创建Stream (1) 获取Stream Java 8中Collection接口被扩展，提供两种获取流的方法:
 stream() 返回一个顺序流 parallelStream()返回一个并行流  1default Stream stream() // 返回一个顺序流 2 3default Stream parallelStream() // 返回一个并行流 1List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 2 3// 顺序流 4Stream&amp;lt;String&amp;gt; stream1 = list.</description>
    </item>
    
    <item>
      <title>Java 8新特性 - (1)Lambda表达式</title>
      <link>https://www.zengxi.net/2021/02/java8_lambda/</link>
      <pubDate>Thu, 25 Feb 2021 13:15:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/02/java8_lambda/</guid>
      <description>为什么Java需要Lambda表达式? 在函数式编程语言中，函数是一等公民，它们可以独立存在，你可以将其赋值给一个变量，或将他们当做参数传给其他函数。JavaScript是最典型的函数式编程语言。函数式语言提供了一种强大的功能——闭包，相比于传统的编程方法有很多优势，闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。
Java现在提供的最接近闭包的概念便是Lambda表达式，虽然闭包与Lambda表达式之间存在显著差别，但至少Lambda表达式是闭包很好的替代者。
Lambda表达式为Java添加了缺失的函数式编程特点，它与闭包不同，但是又无限地接近闭包。在支持一类函数的语言中，Lambda 表达式的类型将是函数。但是，在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。
语法 Java中的Lambda表达式通常使用 (argument) -&amp;gt; (body) 语法书写，例如：
1(arg1, arg2...) -&amp;gt; { body } 2 3(type1 arg1, type2 arg2...) -&amp;gt; { body } 下面是一些例子:
1(int a, int b) -&amp;gt; { return a + b; } 2 3() -&amp;gt; System.out.println(&amp;#34;Hello World&amp;#34;); 4 5(String s) -&amp;gt; { System.out.println(s); } 6 7() -&amp;gt; 42 8 9() -&amp;gt; { return 3.1415 }; Lambda表达式的结构:
 一个 Lambda 表达式可以有零个或多个参数 参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c) 空圆括号代表参数集为空。例如：() -&amp;gt; 42 当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&amp;gt; return a*a Lambda 表达式的主体可包含零条或多条语句 如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致 如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空  函数式接口 在Java中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，也就是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。比如java.</description>
    </item>
    
    <item>
      <title>Java 7新特性 - (1)Java语法特性</title>
      <link>https://www.zengxi.net/2021/02/java7_gramma_new_features/</link>
      <pubDate>Wed, 24 Feb 2021 13:33:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/02/java7_gramma_new_features/</guid>
      <description>二进制数字表达方式 在Java 7之前，支持十进制（123）、八进制（0123）、十六进制（0X12AB）的表示形式。Java 7中增加支持二进制的表示（0B11110001、0b11110001）
1int binary = 0b0001_1001; 2System.out.println(&amp;#34;binary is :&amp;#34; + binary); 输出
1binary is :25 使用下划线对数字进行分隔表达 Java 7中支持在数字中间增加&#39;_&#39;作为分隔符，分隔长int以及long（也支持double,float），显示更直观，如（12_123_456）。
下划线只能在数字中间，编译时编译器自动删除数字中的下划线。
1int intOne = 1_000_000; 2long longOne = 1_000_000; 3double doubleOne = 1_000_000; 4float floatOne = 1_000_000; switch 语句支持字符串变量 之前在switch中只能使用number或enum，Java 7开始支持string。
1String s = &amp;#34;a&amp;#34;; 2switch (s) { 3 case &amp;#34;a&amp;#34;: 4 System.out.println(&amp;#34;is a&amp;#34;); 5 break; 6 case &amp;#34;b&amp;#34;: 7 System.out.println(&amp;#34;is b&amp;#34;); 8 break; 9 default: 10 System.out.println(&amp;#34;is c&amp;#34;); 11 break; 12} 泛型实例创建的类型推断 运用泛型实例化类型自动推断，对通用实例创建(diamond)的type引用进行了改进，语法更加简洁</description>
    </item>
    
    <item>
      <title>用string adapter来解决系统接口对接中发现的空值验证问题</title>
      <link>https://www.zengxi.net/2020/06/string_adapter/</link>
      <pubDate>Mon, 01 Jun 2020 13:44:01 +0000</pubDate>
      
      <guid>https://www.zengxi.net/2020/06/string_adapter/</guid>
      <description>客户用的是很旧版本的ERP系统，在与客户系统做接口对接的时候发现了一个问题。假设接口请求需要的body是xml格式的，共有三个字段：name, mobile, email。由于客户ERP系统比较老，如果某个字段没有值，传的是空字符串，而不是将该字段在请求消息体中隐藏。客户发的请求类似下面的例子：
1&amp;lt;xml&amp;gt; 2 &amp;lt;name&amp;gt;John&amp;lt;/name&amp;gt; 3 &amp;lt;mobile&amp;gt;13800138000&amp;lt;/mobile&amp;gt; 4 &amp;lt;email&amp;gt;&amp;lt;/email&amp;gt; 5&amp;lt;/xml&amp;gt; 由于历史遗留问题，我方系统里在字段上面加了 javax.validation.constraints.Pattern 注解使用正则表达式来对传入的请求值做验证。当传入值为空字符串的时候，正则表达式验证就无法通过。
与客户做过沟通，对于空值的字段，他们也没有办法在请求中隐藏字段，只能传空字符串。那就只能在我方系统这边看看是否可以通过修改代码来解决。一种方案是修改正则表达式，来兼容空字符串，但是由于这些都是传统代码，不确定把空字符串设置在这个字段上面会对后面的处理会有什么影响。如果有更合适的、代价更小的方案，那么就最好不选择这种。
1@XmlType 2@XmlAccessorType(XmlAccessType.FIELD) 3public class TestRequest implements Serializable { 4 @XmlElement(required = true) 5 private String name; 6 7 @XmlElement(required = false) 8 @Pattern(regexp = Constants.regexpMobile, message = &amp;#34;invalidMobile&amp;#34;) 9 private String mobile; 10 11 @XmlElement(required = false) 12 @Pattern(regexp = Constants.regexpEmail, message = &amp;#34;invalidEmail&amp;#34;) 13 private String email; 14 15 // getter / setter 16 .</description>
    </item>
    
    <item>
      <title>通过SSH和JMX远程监控Java服务</title>
      <link>https://www.zengxi.net/2018/06/connect-remote-jmx-with-ssh/</link>
      <pubDate>Thu, 28 Jun 2018 09:26:06 +0000</pubDate>
      
      <guid>https://www.zengxi.net/2018/06/connect-remote-jmx-with-ssh/</guid>
      <description>在日常工作中，可以使用一些监控数据的图形展示工具（比如Grafana等）来查看服务器上面JVM的使用情况，比如内存或者CPU的占用情况。但是，在需要解决实际问题的时候，比如CPU或者内存占用过高，还是需要连接到远程的服务器，查看JVM的具体运行情况来分析问题产生的原因。
通常情况下，我们是通过开启远程服务器上的JMX，使用JVisualVM或JConsole客户端，远程连接到服务器上。然而，在实际的生产环境中，Java应用服务器并没有直接暴露在公网，必须通过跳板机来连接。
网上查了一些资料，多数比较麻烦，有些还需要借助第三方工具。后来找到一个简便的方法，在使用JVisualVM或JConsole客户端的时候，通过指定socks代理的方式来连接远程服务器。下面是具体的步骤。
Java应用开启JMX 在应用启动命令里面添加下面的参数。指定JMX端口为18888
 -Dcom.sun.management.jmxremote.port=18888 -Dcom.sun.management.jmxremote.rmi.port=18888 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
 指定本地socks代理的端口和跳板机 在命令行中执行下面的命令开启端口转发
1ssh -N -D 10099 my-bastion 注意：
 上述例子中的 my-bastion 是跳板机别名，在 ~/.ssh/config中配置。 10099 是绑定的本地端口号 ssh命令帮助文档中对两个参数的解释:   -N Do not execute a remote command. This is useful for just forwarding ports. -D [bind_address:]port Specifies a local “dynamic” application-level port forwarding.  用工具连接远程jvm JConsole客户端 如果使用jconsole客户端连接。可以直接指定需要连接的服务
1jconsole -J-DsocksProxyHost=localhost -J-DsocksProxyPort=10099 service:jmx:rmi:///jndi/rmi://10.10.3.11:18888/jmxrmi JVisualVM客户端 如果使用jvisualvm客户端连接，先启动指定代理服务器的参数来启动jvisualvm
1jvisualvm -J-DsocksProxyHost=localhost -J-DsocksProxyPort=10099 然后在jvm里面先添加remote host，再添加类似下面的JMX连接
 service:jmx:rmi:///jndi/rmi://10.10.3.11:18888/jmxrmi
 双击左边添加好的JMX连接，就可以连上服务器并监控JVM的实际状况了</description>
    </item>
    
    <item>
      <title>实现InputStream的序列化</title>
      <link>https://www.zengxi.net/2018/06/inputstream-serialize/</link>
      <pubDate>Tue, 12 Jun 2018 10:57:35 +0000</pubDate>
      
      <guid>https://www.zengxi.net/2018/06/inputstream-serialize/</guid>
      <description>InputStream本身是不支持序列化的，但是在实际开发的过程中有时会需要将输入流通过socket传输，比如RMI的远程调用。
在Serializable的Java文档文档中有下面的描述：
 Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures:
 private void writeObject(java.io.ObjectOutputStream out) throws IOException private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; private void readObjectNoData() throws ObjectStreamException;  1 2对于这个场景，序列化的类只需实现writeObject与readObject这两个方法就足够了。readObjectNoData这个方法只是在特定的情况下才需要用，对于简单的应用场景来说，可以不用实现。 3 4为了实现输入流的序列化，需要新建一个继承于Serializable接口的实体类，序列化的时候将输入流转成字节数组（writeObject方法），反序列化则将字节流转成输入流（readObject方法）。值得注意的是，这里要用到transient关键字来修饰不可序列化的InputStream私有字段。 5 6示例代码： 7```java 8public class SerializableStream implements Serializable { 9 private final static int LENGTH = 1024; 10 private transient InputStream inputStream; 11 12 public SerializableStream(InputStream is) { 13 this.</description>
    </item>
    
  </channel>
</rss>
