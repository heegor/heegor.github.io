<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 保罗札记</title>
    <link>https://www.zengxi.net/tags/java/</link>
    <description>Recent content in java on 保罗札记</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 24 Feb 2021 13:33:00 +0800</lastBuildDate><atom:link href="https://www.zengxi.net/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 7新特性 - (1)Java语法特性</title>
      <link>https://www.zengxi.net/2021/02/java7_gramma_new_features/</link>
      <pubDate>Wed, 24 Feb 2021 13:33:00 +0800</pubDate>
      
      <guid>https://www.zengxi.net/2021/02/java7_gramma_new_features/</guid>
      <description>二进制数字表达方式 在Java 7之前，支持十进制（123）、八进制（0123）、十六进制（0X12AB）的表示形式。Java 7中增加支持二进制的表示（0B11110001、0b11110001）
1int binary = 0b0001_1001; 2System.out.println(&amp;#34;binary is :&amp;#34; + binary); 输出
1binary is :25 使用下划线对数字进行分隔表达 Java 7中支持在数字中间增加&#39;_&#39;作为分隔符，分隔长int以及long（也支持double,float），显示更直观，如（12_123_456）。
下划线只能在数字中间，编译时编译器自动删除数字中的下划线。
1int intOne = 1_000_000; 2long longOne = 1_000_000; 3double doubleOne = 1_000_000; 4float floatOne = 1_000_000; switch 语句支持字符串变量 之前在switch中只能使用number或enum，Java 7开始支持string。
1String s = &amp;#34;a&amp;#34;; 2switch (s) { 3 case &amp;#34;a&amp;#34;: 4 System.out.println(&amp;#34;is a&amp;#34;); 5 break; 6 case &amp;#34;b&amp;#34;: 7 System.out.println(&amp;#34;is b&amp;#34;); 8 break; 9 default: 10 System.out.println(&amp;#34;is c&amp;#34;); 11 break; 12} 泛型实例创建的类型推断 运用泛型实例化类型自动推断，对通用实例创建(diamond)的type引用进行了改进，语法更加简洁</description>
    </item>
    
    <item>
      <title>用string adapter来解决系统接口对接中发现的空值验证问题</title>
      <link>https://www.zengxi.net/2020/06/string_adapter/</link>
      <pubDate>Mon, 01 Jun 2020 13:44:01 +0000</pubDate>
      
      <guid>https://www.zengxi.net/2020/06/string_adapter/</guid>
      <description>客户用的是很旧版本的ERP系统，在与客户系统做接口对接的时候发现了一个问题。假设接口请求需要的body是xml格式的，共有三个字段：name, mobile, email。由于客户ERP系统比较老，如果某个字段没有值，传的是空字符串，而不是将该字段在请求消息体中隐藏。客户发的请求类似下面的例子：
1&amp;lt;xml&amp;gt; 2 &amp;lt;name&amp;gt;John&amp;lt;/name&amp;gt; 3 &amp;lt;mobile&amp;gt;13800138000&amp;lt;/mobile&amp;gt; 4 &amp;lt;email&amp;gt;&amp;lt;/email&amp;gt; 5&amp;lt;/xml&amp;gt; 由于历史遗留问题，我方系统里在字段上面加了 javax.validation.constraints.Pattern 注解使用正则表达式来对传入的请求值做验证。当传入值为空字符串的时候，正则表达式验证就无法通过。
与客户做过沟通，对于空值的字段，他们也没有办法在请求中隐藏字段，只能传空字符串。那就只能在我方系统这边看看是否可以通过修改代码来解决。一种方案是修改正则表达式，来兼容空字符串，但是由于这些都是传统代码，不确定把空字符串设置在这个字段上面会对后面的处理会有什么影响。如果有更合适的、代价更小的方案，那么就最好不选择这种。
1@XmlType 2@XmlAccessorType(XmlAccessType.FIELD) 3public class TestRequest implements Serializable { 4 @XmlElement(required = true) 5 private String name; 6 7 @XmlElement(required = false) 8 @Pattern(regexp = Constants.regexpMobile, message = &amp;#34;invalidMobile&amp;#34;) 9 private String mobile; 10 11 @XmlElement(required = false) 12 @Pattern(regexp = Constants.regexpEmail, message = &amp;#34;invalidEmail&amp;#34;) 13 private String email; 14 15 // getter / setter 16 .</description>
    </item>
    
    <item>
      <title>通过SSH和JMX远程监控Java服务</title>
      <link>https://www.zengxi.net/2018/06/connect-remote-jmx-with-ssh/</link>
      <pubDate>Thu, 28 Jun 2018 09:26:06 +0000</pubDate>
      
      <guid>https://www.zengxi.net/2018/06/connect-remote-jmx-with-ssh/</guid>
      <description>在日常工作中，可以使用一些监控数据的图形展示工具（比如Grafana等）来查看服务器上面JVM的使用情况，比如内存或者CPU的占用情况。但是，在需要解决实际问题的时候，比如CPU或者内存占用过高，还是需要连接到远程的服务器，查看JVM的具体运行情况来分析问题产生的原因。
通常情况下，我们是通过开启远程服务器上的JMX，使用JVisualVM或JConsole客户端，远程连接到服务器上。然而，在实际的生产环境中，Java应用服务器并没有直接暴露在公网，必须通过跳板机来连接。
网上查了一些资料，多数比较麻烦，有些还需要借助第三方工具。后来找到一个简便的方法，在使用JVisualVM或JConsole客户端的时候，通过指定socks代理的方式来连接远程服务器。下面是具体的步骤。
Java应用开启JMX 在应用启动命令里面添加下面的参数。指定JMX端口为18888
 -Dcom.sun.management.jmxremote.port=18888 -Dcom.sun.management.jmxremote.rmi.port=18888 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
 指定本地socks代理的端口和跳板机 在命令行中执行下面的命令开启端口转发
1ssh -N -D 10099 my-bastion 注意：
 上述例子中的 my-bastion 是跳板机别名，在 ~/.ssh/config中配置。 10099 是绑定的本地端口号 ssh命令帮助文档中对两个参数的解释:   -N Do not execute a remote command. This is useful for just forwarding ports. -D [bind_address:]port Specifies a local “dynamic” application-level port forwarding.  用工具连接远程jvm JConsole客户端 如果使用jconsole客户端连接。可以直接指定需要连接的服务
1jconsole -J-DsocksProxyHost=localhost -J-DsocksProxyPort=10099 service:jmx:rmi:///jndi/rmi://10.10.3.11:18888/jmxrmi JVisualVM客户端 如果使用jvisualvm客户端连接，先启动指定代理服务器的参数来启动jvisualvm
1jvisualvm -J-DsocksProxyHost=localhost -J-DsocksProxyPort=10099 然后在jvm里面先添加remote host，再添加类似下面的JMX连接
 service:jmx:rmi:///jndi/rmi://10.10.3.11:18888/jmxrmi
 双击左边添加好的JMX连接，就可以连上服务器并监控JVM的实际状况了</description>
    </item>
    
    <item>
      <title>实现InputStream的序列化</title>
      <link>https://www.zengxi.net/2018/06/inputstream-serialize/</link>
      <pubDate>Tue, 12 Jun 2018 10:57:35 +0000</pubDate>
      
      <guid>https://www.zengxi.net/2018/06/inputstream-serialize/</guid>
      <description>InputStream本身是不支持序列化的，但是在实际开发的过程中有时会需要将输入流通过socket传输，比如RMI的远程调用。
在Serializable的Java文档文档中有下面的描述：
 Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures:
 private void writeObject(java.io.ObjectOutputStream out) throws IOException private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; private void readObjectNoData() throws ObjectStreamException;  1 2对于这个场景，序列化的类只需实现writeObject与readObject这两个方法就足够了。readObjectNoData这个方法只是在特定的情况下才需要用，对于简单的应用场景来说，可以不用实现。 3 4为了实现输入流的序列化，需要新建一个继承于Serializable接口的实体类，序列化的时候将输入流转成字节数组（writeObject方法），反序列化则将字节流转成输入流（readObject方法）。值得注意的是，这里要用到transient关键字来修饰不可序列化的InputStream私有字段。 5 6示例代码： 7```java 8public class SerializableStream implements Serializable { 9 private final static int LENGTH = 1024; 10 private transient InputStream inputStream; 11 12 public SerializableStream(InputStream is) { 13 this.</description>
    </item>
    
  </channel>
</rss>
